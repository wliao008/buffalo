\chapter{Implementation}

\section{How to Apply an Aspect}

Since an aspect is really a .NET attribute, it can be used just like any other attribute. However, code annotated with an aspect is special in that it can be understood only by Buffalo.

A Buffalo aspect can be applied on three levels, with the following characteristics:

\begin{enumerate}
  \item Method - apply the aspect to an individual method.
  \item Class - if aspect is applied to a class, all public methods, including the public properties, are automatically applied.
  \item Assembly - if aspect is applied to an assembly, \#2 will apply for all of the public classes within the assembly.
\end{enumerate}

An exception to the above rule is the MethodAroundAspect, where it can only be applied on a method level, as will be shown later.

All aspects have a property named AttributeExclude; if this property is set to true, then the annotated target will not be included in the weaving. This exclusion can happen on any level. For example, if a method contains this annotation [SampleAspect(AttributeExclude=true)], the method will be skipped for the SampleAspect during the weaving process.

No matter how the aspect is applied, ultimately it will result in a list of the methods that are annotated. This simply means that if the aspect is applied to a single method, that method is the only one that will get CIL modified. If the aspect is applied on the whole assembly, then all public methods will be CIL modified.

To get the list of the eligible methods for CIL modification, Buffalo attempts various checking according to Figure~\ref{logical_inclusion} to see if it should include a given method.

\begin{figure}[H]
  \includegraphics[scale=1.0]{AspectLogicalInclusion2.PNG}
  \centering
  \caption{Diagram for Finding Eligible Methods\label{logical_inclusion}}
\end{figure}

If no aspect is applied on the assembly, it does not necessarily mean no aspect is applied anywhere; the aspect might still be applied on any given class or method.

Buffalo first checks if an aspect is applied to the target, and then checks if it is set to be excluded. At the end it will end up with a list of methods that should be CIL modified.

\section{Aspect Interface}

Figure~\ref{uml01} shows the relationship of various aspect types in Buffalo. This is used by Buffalo to identify aspects during reflection.

\begin{figure}[H]
  \includegraphics[scale=1.0]{Uml02.PNG}
  \centering
  \caption{Aspect Inheritance\label{uml01}}
\end{figure}

All aspects ultimately implement the IAspect interface; therefore, it can be reasoned that for all the public types in an assembly that if a type implements IAspect, then it must be an aspect itself.

Buffalo supports more than one aspect applied at any given level. This will allow developers more flexibility while developing multiple aspects and applying them as needed.

Furthermore, by default, an aspect will be automatically excluded from applying to itself. This is implemented to prevent stack overflow in some cases. Although argument can be made that an aspect should be able to be applied to a different aspect; that is not currently implemented in Buffalo.

Listing~\ref{aspectexample} shows how a simple aspect is created. It inherits MethodBoundaryAspect and overrides OnBefore and OnAfter.

\begin{lstlisting}[caption={Sample TraceAspect}, label=aspectexample]
using Buffalo;
using System;

public class TraceAspect : MethodBoundaryAspect
{
    public override void OnBefore(MethodArgs args)
    {
        Display("ENTERING", args);
    }

    public override void OnAfter(MethodArgs args)
    {
        Display("EXITING", args);
    }

    void Display(string title, MethodArgs args)
    {
        Console.WriteLine("{0} {1}", title, args.FullName);
        foreach (var p in args.Parameters)
        {
            Console.WriteLine("\t{0} ({1}) = {2}", 
			p.Name, p.Type, p.Value);
        }
    }
}
\end{lstlisting}

To use the aspect, simply apply it to a method, class or assembly. Once the code is compiled to produce an assembly, BuffaloAOP.exe can be invoked by passing it the path to the assembly. Buffalo will take over and weave in the aspect. This and more examples and details are provided in Appendix A.

\begin{lstlisting}[caption={Apply Aspect on Class Level}, label=helloaspect]
[TraceAspect]
public class Hello
{
	//...
}
\end{lstlisting}

\section{MethodArgs}

As mentioned above, when all is said and done, an aspect ultimately gets injected into each \textit{individual} method. When developing an aspect, meta-information about the target method can be accessed. This information is encapsulated via the MethodArgs object passed in as parameter to the aspect. Method name, its full method signature, return type and parameter list (including parameter name, type and value) are captured for each target method.

The parameter list capturing is especially of interest; it enables the developer to peek inside the method that is executing at various point and inspect its parameter values. This will be useful in cases such as exception handling, where it will be useful to see what the actual values were at the time of the exception. When using MethodAroundAspect, the parameter values can even be modified and passed back to the original method.

\section{Visual Studio Solution Structure}

Originally Buffalo was implemented as one executable; that includes the various aspects and the program that initiates the weaving. It was later separated into two assemblies. One is a class library that contains the actual implementation. Another is a command line executable that calls into the class library to perform the weaving. This separation is necessary so that the developer can perform weaving from the command line or hook into MS-Build if necessary. 

To actually write the aspect, one only needs to reference the class library as underlined in Figure~\ref{solutionexplorer}.

\begin{figure}[H]
  \includegraphics[scale=1.0]{SolutionExplorer3.PNG}
  \centering
  \caption{Solution Structure\label{solutionexplorer}}
\end{figure}

The client project shown above is a simple program included in the solution for testing.

\section{Implementation Overview}

The implementation begins by finding all eligible methods to be injected using the verification process indicated in Figure~\ref{logical_inclusion}. Each eligible method will have one or more aspects applied to it. The actual injection process will loop through each aspect for the eligible method and inject the necessary CIL instructions.

The CIL instructions modification is performed by using the open-source Mono.Cecil library. Originally, the System.Reflection APIs in the .NET Framework were favored, but it was later determined that Mono.Cecil provides more features and is much easier to work with. Buffalo uses Mono.Cecil heavily to modify CIL instructions and to assemble the final assembly.

\section{MethodBoundaryAspect Implementation Detail}

Each type of aspect has its own injector that implements the IInjectable interface. This interface contains only one method contract - Inject(..). It takes the list of eligible methods and injects the appropriate aspect to them.

MethodBoundaryAspect is pretty straightforward to implement. Take the following hello-world example wrapped in a try-catch-finally block as mentioned previously:

\begin{lstlisting}[caption={SayHello Function}, label=sayhello]
public void SayHello()
{
   try{
       Console.WriteLine(“Hello World!”);
   }catch(Exception ex){
   }finally{
   }
}
\end{lstlisting}

The generated CIL is shown in Figure~\ref{methodboundaryB4}. For ease of display, the CIL has been cleaned up a bit:

\begin{lstlisting}[caption={CIL Generated for Sample C\# Function}, label=methodboundaryB4]
.try
{
   .try
   {
      IL_0002: Ldstr "Hello World!"
      IL_0007: call void [mscorlib]System.Console::WriteLine(string)
      IL_000e: leave.s IL0015
   }
   catch [mscorlib]System.Exception
   {
      IL_0010: stloc.0
      IL_0013: leave.s IL_0015
   }
   IL_0015: leave.s IL_001c
}
finally
{
   IL_001a: endfinally
}
IL_001c: ret
\end{lstlisting}

Figure~\ref{methodboundaryB4} shows the standard emission of the CLR when it encounters the try-catch-finally statement. In CLR, there is a concept of the protected region, where each region is associated with a handler. A try-catch-finally is actually encapsulated in two such regions: a catch and a finally. From here, it can be easily figured out where to inject the various boundary aspects, as shown in Figure~\ref{methodboundary02}.

\begin{figure}[H]
  \includegraphics[scale=1.0]{MethodBoundaryOverview.PNG}
  \centering
  \caption{CIL Interception Points\label{methodboundary02}}
\end{figure}

\section{MethodAroundAspect Implementation Detail}

The MethodAroundAspect, on the other hand, is a much more complicated when compared to the MethodBoundaryAspect.

MethodAroundAspect implements IMethodAroundAspect which has the following contract:

\begin{lstlisting}[caption={IMethodAroundAspect Interface}, label=aroundcontract]
internal interface IMethodAroundAspect : IAspect
{
	void Invoke(MethodArgs args)
}
\end{lstlisting}

In the development of an aspect, a Proceed() can be issued to signal a call back into the original method. The steps taken to implement MethodAroundAspect in CIL are roughly as follows:

\begin{enumerate}
	\item Create a replacement for the annotated function with exactly the same method signature.
	\item Create and store a variable pointing to the aspect.
	\item Copy all parameters from original method to the newly created replacement function.
	\item Create a variable to hold MethodArgs.
	\item Issue a call to Invoke() from the replacement function, passing in the MethodArgs variable.
	\item Handle the return value appropriately.
	\begin{enumerate}
		\item If the original method returns non-void type, then put the return value back on the stack.
		\item If the original method returns void, discard the return value from Invoke().
	\end{enumerate}
	\item Handle Proceed() that might be issued from inside the Invoke().
	\begin{enumerate}
		\item Load all the parameters onto the stack.
		\item Call back into the original method.
		\item Handle the return value appropriately.
	\end{enumerate}
	\item Modify all calls from original method to the replacement method.
\end{enumerate}

As Figure~\ref{around_overview} shows, the actual calling of either the original or replacement method is abstracted away. This is also a testament of the saying in software engineering that "anything can be resolved by another layer of abstraction."

Another important distinction is that MethodAroundAspect currently can be applied only on the method level, and that it should be applied to one method only. This is by design because a replacement method might not be appropriate to replace more than one method. Especially if the aspect is applied on the assembly level, all the public methods will be replaced by a single replacement method.

\section{MethodArgs Implementation Detail}

When an aspect is being developed, information about the target method can be accessed. This is achieved by using the MethodArgs object. During the weaving, an instance of MethodArgs is created with all properties assembled dynamically to capture the information of the current executing method. MethodArgs is then passed as a parameter into each of the aspect.

Being able to capture some information about the annotated methods will be  extremely useful in cases where debugging becomes necessary.

A distinct instance of MethodArgs for each boundary aspect was instantiated in an early Buffalo implementation. Later on as an optimization, only one instance is instantiated at the beginning of the method body, and that instance is used in all the boundary aspects for a target method.

An example of how to use MethodArgs is presented in the user manual.
