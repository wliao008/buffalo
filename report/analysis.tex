\chapter{Analysis}

The project hypothesized that by using Buffalo, programmers can separate the cross-cutting concerns from their applications quickly and easily. Since the concerns are encapsulated in a distinct unit of code, it also enables programmers to easily maintain the aspects and modify them as needed.

One analysis performed is to write an aspect to catch unhandled exceptions in test programs. The size of the test programs varies from comprising of 50 methods to 1,000 methods. Suppose that to manually implement the exception handling, a programmer will have to write on average 5 lines of code to catch the exception.

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
Programs & Lines (Traditions) & Lines (Buffalo)\\
\hline
50 & 250 & 0-1\\
500 & 2,500 & 0-1\\
1,000 & 5,000 & 0-1\\
\hline
\end{tabular}
\caption{Line counts}
\label{tab:lines_tbl}
\end{table}

If exception handling is implemented for every method by hand, more line of the same try-catch block of code will have to be written as the application adds more methods. The number of line of repetitive code would increase linearly.

Lines of code have a direct correlation to the cost of the development as it will take programmers more time. And this will also have a direct impact on application release schedule.

By using a framework like Buffalo, unhandled exception can be centralized in one aspect, and then simply apply it to every method by applying it on the assembly level. 

As a result the source code is free from the repetitive try-catch-finally blocks. The line of code we have to write is one line at most, and will stay constant even as more types and methods are added to the application. This will also give developer a peace of mind that every method will be handled automatically.

One can argue that since unhandled exceptions will bubble up the chain, a developer can simply catch them in the main method, and this would have achieved similar effect. That approach is limited in that it is very generic. When the main method catches an exception, it has no idea what the internal state of the failed method was. Using Buffalo, the internal state can be inspected by checking the MethodArgs object. 

Besides exception handling, Buffalo can be used in scenarios where cross-cutting concerns are common. One problem facing developers when working on database is to ensure data atomicity. Imagine a customer who deposits money to a bank, the amount is saved successfully to the bank’s own record, but the customer’s account failed to get updated due to unforeseeable network error. Not only would the database end up with incomplete data, but the bank would have a very unhappy customer. Either all operations are successfully completed or nothing should have been written to the database.

Buffalo can be used to solve this problem by encapsulating transactional scope using the MethodBoundaryAspect. Complete example is available in Appendix A.

Developers that work with UI elements often run into problems updating the UI from a different thread. As UI elements can be updated only by thread that created them, this creates the cross-threading problem. Buffalo’s MethodAroundAspect can be used to get around this problem by marshaling the update back to the UI thread. For more detail please refer to Appendix A.

Buffalo allows developers to quickly create aspects to solve various problems. Besides the scenarios mentioned above, it can also be used for authorization, where security credential is validated before method execution. It can be used to create a caching mechanism to improve application performance. Buffalo has performed well in isolating cross-cutting concerns into single unit of code, which is easily maintained and modified.
