\chapter{Analysis}

The project hypothesized that by using Buffalo, programmers can separate the cross-cutting concerns from their applications quickly and easily. Since the concerns are encapsulated in a distinct unit of code, it also enables programmers to easily maintain the aspects and modify them as needed.

One analysis performed is to write an aspect to catch unhandled exceptions in test programs. The size of the test programs varies from comprising of 50 methods to 1,000 methods. Suppose that to manually implement the exception handling, a programmer will have to write on average 5 lines of code to catch the exception.

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
Programs & Lines (Traditions) & Lines (Buffalo)\\
\hline
50 & 250 & 0-1\\
500 & 2,500 & 0-1\\
1,000 & 5,000 & 0-1\\
\hline
\end{tabular}
\caption{Line counts}
\label{tab:lines_tbl}
\end{table}

If exception handling is implemented for every method by hand, more line of the same try-catch block of code will have to be written as the application adds more methods. The number of line of repetitive code would increase linearly.

Lines of code have a direct correlation to the cost of the development as it will take programmers more time. And this will also have a direct impact on application release schedule.

By using a framework like Buffalo, unhandled exception can be centralized in one aspect, and then simply apply it to every method by applying it on the assembly level. 

As a result the source code is free from the repetitive try-catch-finally blocks. The line of code we have to write is one line at most, and will stay constant even as more types and methods are added to the application. This will also give developer a peace of mind that every method will be handled automatically.

One can argue that since unhandled exceptions will bubble up the chain, a developer can simply catch them in the main method, and this would have achieved similar effect. That approach is limited in that it is very generic. When the main method catches an exception, it has no idea what the internal state of the failed method was. Using Buffalo, the internal state can be inspected by checking the MethodArgs object. 

Buffalo allows developer to quickly create aspects to solve various problems, from unhandled exception to instrumenting the application. These are just some of the scenarios where Buffalo proves to be helpful. More examples are provided in Appendix A. 

Buffalo has performed well in isolating cross-cutting concerns into single unit of code, which is easily maintained and modified.
