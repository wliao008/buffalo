%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% PROJECT PROPOSAL  DESCRIPTION:
%   A concise description of the main concepts of the proposed project.
%
% RESEARCH:
%   A list of research activities which led to this project.
%
% EXPERIMENTS:
%   A list of the experiments performed which supported the research.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Define a single space environment (copied from doublespace.sty)
% e.g. \begin{singlespace}
%         single-spaced text
%      \end{singlespace}

\documentclass[12pt,american]{article}
\usepackage{fullpage}
\usepackage{bbm}
\usepackage{url}
\usepackage{subfigure}
\usepackage{babel}
\usepackage{times}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{lscape}
\usepackage{verbatim}
\usepackage{enumerate}
\usepackage{afterpage}
\usepackage{setspace}
%\usepackage{parskip}


\begin{document}
\thispagestyle{empty} 
\begin{center}
{\em MS Project Proposal}\\
\vspace{.5in}
{\large \bf An Aspect Oriented Programming Framework for C\#}\\
\vspace{.5in}
{\bf Wei Liao}\\
\vfill
\
{\em Committee Chair:} Prof. James E. Heliotis\\
\vspace{0.1in}
%Signature: \line(1,0) {100} Date: \line(250, 0) {100}\\
{\em Reader: } Prof. Fereydoun Kazemian\\
 \vspace{0.1in}
{\em Observer: } Prof. Matthew Fluet\\
 \vspace{0.1in}
Department of Computer Science\\
B. Thomas Golisano College of Computing and Information Sciences \\
Rochester Institute of Technology \\
Rochester, New York \\ [0.3in]
\vspace{0.5in}
\today{}\\
\end{center}
\vfill

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Collection of useful abbreviations.
\newcommand{\etc} {\emph{etc.\/}}
\newcommand{\etal}{\emph{et~al.\/}}
\newcommand{\eg}  {\emph{e.g.\/}}
\newcommand{\ie}  {\emph{i.e.\/}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Abstract
\section*{Abstract}
Aspect Oriented Programming (AOP) is a paradigm that let programmers isolate and separate cross-cutting concerns from the basis of their program. The concept is relatively new, so very few languages has native support for this capability, support in toolings such as IDE integration is also rare. In this project we will design and implement a framework that provides AOP functionality for C\# via IL code weaving and integrate it with the Visual Studio IDE.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vfill{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This is where the main body of the capstone proposal starts
\setcounter{page}{0} 
\newpage{}
%\setlength{\parindent}{1cm}
\section{Introduction}
The current breed of high level programming languages such as JAVA and C\# have given programmers a lot of freedom in expressing themselves in Object Oriented Design. However they are still lacking in some areas when it comes to some particular software design decision such as cross-cutting concern. 

In this project we will design and implement a framework for the C\# platform that will help programmers solve this type of problems.

In section 2 we will dive into some of the areas that the current programming paradigm are not efficient at solving, we will look at some examples. In section 3 we will look at existing works and what have been done. In section 5 we will explain what we propose to do and give and overview of the architecture of the framework that we will implement, and what we want the end result to be. A tentative roadmap is given in section 6.

\section{Background}
\subsection{The Problem}
Procedural Language such as C achieves modularity by grouping codes into subroutines or functions, whereas Object Oriented Programming (OOP) such as JAVA or C\# go one step further, and they allow programmers to abstract real world object into properties and behaviors.

While both paradigms give programmers of that languages the ability to make their code cleaner and more reusable, they are not sufficient to clearly capture some of the important software design decision [1].

In OOP languages, while various objects corresponding to the real world or business requirement can be developed, the usage of the instances of all those objects could still be scattered throughout different modules of the program. Overtime, these tangled cross-cutting concerns [1] can be difficult and expensive maintenance. One of the often cited example of such concern is exception handling, the ability to for programs to handle errors or die gracefully.

To handle exception in our code, in its most basic form we can have the follow try..catch block:
\begin{verbatim}
01. public void SomeFunction() {
02.    try {
03.        //this will fail
04.        var result = 1 / zero;
05.        //other operations...
06.    } catch (Exception e) {
07.        //log exception to file, etc
08.        Utility.LogToFile(e);
09.    }
10. }
\end{verbatim}

Line 4 is going to throw an exception, now imagine if you have 10,000 functions in your program that can potentially throw errors, you would have to apply the try..catch block on all of them. Note that the fact that the functionality of actually logging the exception is nicely encapsulated in the Utility object, but still it will be invoked in 10,000 different places. Since your program most likely will be consist of many modules, it will mean this repetitive pattern will cut through and appears in all your modules.

Imagine again, wif you need to fine tune this try..catch block to catch a specific exception such as the DivideByZeroException so your program can act accordingly, or instead of using the Utility object you want to use a different object to handle the actual logging. In the worst case you would have to make the change to all 10,000 of your functions.

The problem is how to isolate those cross-cutting concerns from loitering your program. Aspect Oriented Programming technique [1] can be used to cleanly separate such concerns.

\subsection{Aspect-Oriented Programming}
The Aspect Oriented Programming paradigm is first discussed in the 1997 paper ~\cite{aop}. When talk about AOP, the following concepts are worth noting.

{\em concern} - It is the repetitive code that cross-cut into different modules of the program. It is often code that does not conviently fit into the dominant paradigm of design.

{\em aspect} - It is the piece of isolated code that can be used to solve the issue of a particluar concern.

{\em join points} - Locations through out the program where the concern might be cut into, it is also where the aspect will be applied.

From the above concept we should have a pretty clear idea that first, we have some cross-cutting code that's not easy to maintaint, so we can isolate them into a separate piece of code, then we can injects the aspect into all relevant places in a program.

\section{Related Work}Like other programming paradigms, AOP is most effective and beneficial to programmers when it is supported on the compiler level, and make it a first class citizen like other properties of a language. As of now, very few languages provide native support, Delphi Prism 2010 is one of them, where the weaving of aspect code happens at compile time ~\cite{delphi_prism2010}. But most languages currently rely on compiler extension or framework to provide the support.

\subsection{Compile Support}

Along with the 1997 paper, the authors also presented an implementation of AOP for the JAVA platform called AspectJ. AspectJ is a language in and of itself, with its own specific syntax and usages and even compiler. It would have been nice if this is extended directly in the JAVA compiler, which some hopes it will happen soon. But still, AspectJ integrated nicely with JAVA, especially when used in an Integrated Development Environment (IDE) like Eclipse.

AspectJ can introduce new features to or modify an existing code base, it provides the aspect keyword to denote a piece of code as an advice, in contrast to the class keyword in JAVA.

[give more detail on how aspectj is used, example?]

AspectJ does bytecode weaving, after JAVA compiles the source, it takes the classes and aspects in bytecode form and weaves them together, producing new .class files that can be loaded onto the virtual machine.

One of the disadvantage of AspectJ is, as the above example shows, the AspectJ syntax is somewhat different from what a JAVA developer would expect, making the learning curve much deeper, but it can prove a powerful tool when get used to.

\subsection{Framework Support}

AspectJ is one of the few compiler that does AOP, for the vast programming languages out there, support is provided via some sort of frameworks. This is especially evident on the C\# platform ~\cite{aopcs}, as things are not that cosy with AOP. Ander Heijsburg is the Microsoft fellow that lead the team to develop the C\# compiler, he has indicated that they will not be integrating support for AOP on the compiler anytime soon. Although their Patterns \& Practice team release Policy Injection application block that offer some AOP capability.

There are a number of frameworks available for the C\# platform, they come in various flavors and implemented with different technique. There are several approaches and each has its advantages and disadvantage.

One of the most common implementation involves the usage of a proxy, where the client does not interact with the objects directly, everything goes through the proxy.

[an image showing the proxy]

The advantage of this approach is relatively easy to implement, but it is also limiting in that in order for the proxy to work, both the proxy and the target object must implement the same interface, therefore the aspect injection point can only occur in the defined virtual functions [need double check on reference]. Since this require reflection at runtime, the performance is usually not as good.

Another approach is similar to AspectJ, where bytecode weaving is involved, but without the extra complexity of a new syntax and language. The most commercially successful implementation of this is PostSharp ~\cite{postsharp}, where aspect weaving happens post compilation by rewriting MSIL instruction set, PostSharp use just the standard C\# language, attribute is used as advice code, the advantage is ease of use, developer already familiar with C\# will have no learning curve at all. And since aspect is woven in the assembly, the runtime has no overhead of reflection and therefore performance is good. Disadvantage being, since it has to work with MSIL instruction set, it is very low level and therefore difficult to implement.

Other approach involve static weaving ~\cite{aspectcs}, where the source files are pre-processed to include all the relevant aspect code, then just let the C\# compile take over and does it work normally. This has the advantage of post compilation weaving but not the MSIL complexity. On the other hand, you do have to develop a parsar generator to efficiently parse the sourc files.

\section{Hypothesis}
Summarize what you think the problem is, and what your hypothesis
is. Here is a small example based on a successful project by Priyanka
Sinha: ''Using one technique for schema matching does not seem
adequate. The hypothesis underlying this sproject is that a holistic
approach to schema matching based on the three techniques described
earlier would do an effective approach to schema matching.''

Additional description to circumscribe the work so that the reader
knows what you plan to do to establish your hypothesis.

\section{Approach and Methodology}
\subsection{Architecture Overview}
There are many approaches on how to implement an AOP framework. The approach I plan to take is to perform post compilation weaving. Figure 1 shows an overview of how the AOP framework will fit in the overall C\# compilation process.

\includegraphics[scale=0.70]{model_overview.png}

From the Visual Studio IDE, developer can use the framework by simply first creating a custom C\# attribue, extending a framework interface IAspect (subject to change), for ex:

\begin{verbatim}
01. public class CatchException : System.Attribute, IAspect() {
02.    public void OnException(Exception e) {
03.        Utility.LogToFile(e);
04.    } 
05. }
\end{verbatim}

Now CatchException will be treated as an aspect by the framework, to use it, simply use it like a regular attribute and annonate it to any method, class or assembly.

\begin{verbatim}
01. [CatchException]
02. public void SomeFunction() {
03.    var result = 1 / zero;
04.    //other operations...
05. }
\end{verbatim}

As the above code snippets shows, the cross-cutting concerns is now cleanly separated into a cutom attribute called CatchException, any change made to the aspect will be propogated to all the annontated functions, class or assembly. As a result. By applying this attribute to the functions, the repetitive try..block is no longer necessary, the target code is much shorter and cleaner. 

The real benefit will be even more evident when an aspect is apply to a large number of functions, or asemblies, for ex, if I want every function within every class to be able to catch exception:

\begin{verbatim}
01. [CatchException]
02. namespace MyAssembly {
03.    public class MyClass {
04.       public void SomeFunction() {
05.          var result = 1 / zero;
06.          //other operations...
07.       }
08.       //other functions...
09.    }
10.    //other classes...
11. }
\end{verbatim}

By applying the attribute on the assembly level, this will effectively will allow every function to have exception handling capability. This will be a huge developer productivity gain.


\subsection{Compile Time Weaving}
Within this method there are a few variants of compile time weaving, one is to preprocess the source files, to perform text transformation to weave all the aspects at the right locations of the source, then just let the compiler take over and compile as normal.

The other type is MSIL rewriting ~\cite{rewrite_msil}, as indicated by figure 1 , the C\# compiler performs a compile on the source files to generate the assembly. This assembly is then fed into the AOP Framework, which will proceed to rewrite the MSIL instruction calls to weave in the aspects.

There are obvious advantages and disadvantages to each method. [Give some examples of what those are?]

\subsection{Platform, Languages and Tools}
This project will be developed using C\#, on the Windows 7 using Visual Studio 2010. When performing IL rewriting there are a few options available, one is to use the Reflection.Emit library that comes with the .NET Framework, however all my researches points to that this library represents only a subset of the MSIL instructions, the missing instruction might prove to be a problem later on.

Another option is to use the Profiler API by Microsoft, however this API is intended as a debugging feature, and therefore is unsuitable to be used in production environment.

While I can opt to invest my time on learning and rolling my own IL rewriter, a more practical option is probably to use a 3rd party library. Mono is an open source implementation of the C\# compiler, Cecil is a project within the Mono project that provides IL rewriting. Preliminary evaluation of the tool seems to be pretty feature complete and flexible enough to allow me to do what I need to do. However documentation for Cecil is next to non-existent, it works with low level MSIL, so I expect the learning curve is probably deep.

The following utility tools will also be heavily used during development: ILSpy, ILDASM and PEVerify. ILSpy is an open source application that dis-assemble assembly to show IL instructions. ILDASM does the same but comes from Microsoftâ€™s .NET Framework. PEVerify is a Microsoft Window SDK tool, it will be used to ensure that the modified assembly produced is a correct assembly.

\section{Roadmap}
The following table shows my tentative schedule for the major phases of the project.

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
Date & Action & Status\\
\hline
07/07/2012 & Pre-Proposal & Accepted\\
07/09/2012 & Proposal & In-progress\\
07/20/2012 & Begin development of the framework & In-progress\\
09/10/2012 & Finish development, start testing and analysis & - \\
09/27/2012 & Finish report & - \\
10/10/2012 & Defense & - \\
\hline
\end{tabular}
\caption{Timeline}
\label{tab:template}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plain}
% Single space the bibliography to save space.
\singlespacing
\bibliography{Proposal}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\end{document}
